<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LaserTime Web Interface</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="main-content">
        <h1>Syntax Scene Dream Machine Panel - Official</h1>
        <div id="statusMessage"></div>
        <nav>
            <button id="navMain">Main Control</button>
            <button id="navMidiOsc">MIDI/OSC Setup</button>
            <button id="navFixture">Fixture Setup</button>
            <button id="navOscDebug">OSC Debug</button>
            <button id="openScenesWindow">Open Scenes</button>
        </nav>
        <div class="content-area">
            <div id="mainControl">
                <h2>Transition</h2>
                <div>
                    <label for="transitionDuration">Transition Duration (ms):</label>
                    <input type="range" id="transitionDuration" min="0" max="10000" step="100" value="1000">
                    <span id="transitionDurationValue">1000 ms</span>
                </div>
                <h2>DMX Channels</h2>
                <div id="dmxChannels"></div>
                <h2>Group Controls</h2>
                <div id="groupControls"></div>
            </div>
            <div id="midiOscSetup" style="display: none;">
                <h2>MIDI Setup</h2>
                <select id="midiInputSelect">
                    <option value="">Select MIDI Input</option>
                </select>
                <button id="forgetAllMidi">Forget All MIDI Mappings</button>
                <h3>MIDI Messages</h3>
                <div id="midiMessages"></div>
            </div>
            <div id="fixtureSetup" style="display: none;">
                <h2>Fixture Management</h2>
                <div id="fixtureForm">
                    <input type="text" id="fixtureName" placeholder="Fixture Name">
                    <input type="number" id="fixtureStartAddress" placeholder="Start Address">
                    <div id="fixtureChannels"></div>
                    <button id="addFixtureChannel">Add Channel</button>
                    <button id="saveFixture">Save Fixture</button>
                </div>
                <div id="fixtureList"></div>
                <h2>Group Management</h2>
                <div id="groupForm">
                    <input type="text" id="groupName" placeholder="Group Name">
                    <select id="groupFixtures" multiple>
                        <!-- Fixture options will be dynamically added here -->
                    </select>
                    <button id="saveGroup">Save Group</button>
                </div>
                <div id="groupList"></div>
            </div>
            <div id="oscDebug" style="display: none;">
                <h2>OSC Debug</h2>
                <div id="oscMessages"></div>
            </div>
            <h2>ArtNET Diagnostics</h2>
            <div id="artnetDiagnostics">
                <p>IP: <span id="artnetIp"></span></p>
                <p>Universe: <span id="artnetUniverse"></span></p>
                <p>Status: <span id="artnetStatus"></span></p>
                <p>Channels Transmitted: <span id="artnetChannelsTransmitted"></span></p>
                <p>Total Channels: <span id="artnetTotalChannels"></span></p>
            </div>
            <h2>ArtNET Device Search</h2>
            <button id="searchArtnetDevices">Search for ArtNET Devices</button>
            <div id="artnetDevices"></div>
            <h2>Settings Management</h2>
            <button id="nukeSettings">NUKE SETTINGS</button>
            <button id="saveAllSettings">Save All Settings</button>
            <button id="loadAllSettings">Load All Settings</button>
        </div>
    </div>
    <div id="debugInfo" style="margin-top: 20px; padding: 10px; background-color: #f1c40f; border-radius: 5px; white-space: pre-wrap; word-wrap: break-word;"></div>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const dmxChannelsContainer = document.getElementById('dmxChannels');
        const groupControlsContainer = document.getElementById('groupControls');
        const fixtureListContainer = document.getElementById('fixtureList');
        const groupListContainer = document.getElementById('groupList');
        const midiInputSelect = document.getElementById('midiInputSelect');
        const statusMessage = document.getElementById('statusMessage');
        const midiMessagesContainer = document.getElementById('midiMessages');
        const oscMessagesContainer = document.getElementById('oscMessages');
        const debugInfo = document.getElementById('debugInfo');
        let currentMidiLearnButton = null;
        let scenesWindow = null;

        function log(message) {
            console.log(message);
            debugInfo.textContent += message + '\n';
        }

        function showStatusMessage(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.className = isError ? 'error' : 'success';
            statusMessage.style.display = 'block';
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 3000);
            log(message);
        }

        // Navigation
        document.getElementById('navMain').addEventListener('click', () => showSection('mainControl'));
        document.getElementById('navMidiOsc').addEventListener('click', () => showSection('midiOscSetup'));
        document.getElementById('navFixture').addEventListener('click', () => showSection('fixtureSetup'));
        document.getElementById('navOscDebug').addEventListener('click', () => showSection('oscDebug'));
        document.getElementById('openScenesWindow').addEventListener('click', openScenesWindow);

        function showSection(sectionId) {
            ['mainControl', 'midiOscSetup', 'fixtureSetup', 'oscDebug'].forEach(id => {
                document.getElementById(id).style.display = id === sectionId ? 'block' : 'none';
            });
        }

        function openScenesWindow() {
            log('Opening scenes window');
            if (scenesWindow && !scenesWindow.closed) {
                scenesWindow.focus();
            } else {
                scenesWindow = window.open('scenes.html', 'ScenesWindow', 'width=400,height=600');
                scenesWindow.onload = () => {
                    log('Scenes window loaded, requesting scene list');
                    socket.emit('getSceneList');
                };
            }
        }

        // Handle initial state
        socket.on('initialState', ({ dmxChannels, fixtures, groups }) => {
            log('Received initial state');
            dmxChannelsContainer.innerHTML = '';
            groupControlsContainer.innerHTML = '';
            
            // Display fixtures and their channels
            fixtures.forEach((fixture, fixtureIndex) => {
                const fixtureDiv = document.createElement('div');
                fixtureDiv.className = 'fixture-item';
                fixtureDiv.innerHTML = `
                    <h3>${fixture.name} (Start: ${fixture.startAddress})</h3>
                    <div class="fixture-channels"></div>
                `;
                const fixtureChannelsDiv = fixtureDiv.querySelector('.fixture-channels');
                
                fixture.channels.forEach((channel, channelIndex) => {
                    const channelDiv = document.createElement('div');
                    channelDiv.className = 'fixture-channel';
                    const dmxAddress = fixture.startAddress + channelIndex;
                    const value = dmxChannels[dmxAddress] || 0;
                    channelDiv.innerHTML = `
                        <label for="fixture-${fixtureIndex}-${channelIndex}">${channel.name} (${channel.type}):</label>
                        <input type="range" id="fixture-${fixtureIndex}-${channelIndex}" min="0" max="255" value="${value}">
                        <span>${value}</span>
                        <button class="midi-learn" data-channel="${dmxAddress}">MIDI Learn</button>
                        <input type="text" class="osc-value" placeholder="OSC Value" value="${channel.oscValue || ''}">
                    `;
                    fixtureChannelsDiv.appendChild(channelDiv);

                    const slider = channelDiv.querySelector('input[type="range"]');
                    const valueDisplay = channelDiv.querySelector('span');
                    slider.addEventListener('input', () => {
                        const newValue = parseInt(slider.value);
                        valueDisplay.textContent = newValue;
                        socket.emit('setFixtureChannel', { fixtureIndex, channelIndex, value: newValue });
                    });

                    const midiLearnButton = channelDiv.querySelector('.midi-learn');
                    midiLearnButton.addEventListener('click', () => {
                        if (currentMidiLearnButton) {
                            currentMidiLearnButton.classList.remove('learning');
                            socket.emit('stopMidiLearn');
                        }
                        if (currentMidiLearnButton !== midiLearnButton) {
                            midiLearnButton.classList.add('learning');
                            socket.emit('startMidiLearn', dmxAddress);
                            currentMidiLearnButton = midiLearnButton;
                        } else {
                            currentMidiLearnButton = null;
                        }
                    });

                    const oscInput = channelDiv.querySelector('.osc-value');
                    oscInput.addEventListener('change', () => {
                        socket.emit('setChannelOsc', { fixtureIndex, channelIndex, oscValue: oscInput.value });
                    });
                });

                dmxChannelsContainer.appendChild(fixtureDiv);
            });

            // Display remaining DMX channels
            const usedChannels = fixtures.reduce((acc, fixture) => acc + fixture.channels.length, 0);
            for (let i = usedChannels; i < 512; i++) {
                const channelDiv = document.createElement('div');
                channelDiv.className = 'dmx-channel';
                channelDiv.innerHTML = `
                    <label for="dmx-${i}">Channel ${i + 1}:</label>
                    <input type="range" id="dmx-${i}" min="0" max="255" value="${dmxChannels[i] || 0}">
                    <span>${dmxChannels[i] || 0}</span>
                    <button class="midi-learn" data-channel="${i}">MIDI Learn</button>
                    <input type="text" class="osc-value" placeholder="OSC Value">
                `;
                dmxChannelsContainer.appendChild(channelDiv);

                const slider = channelDiv.querySelector('input[type="range"]');
                const valueDisplay = channelDiv.querySelector('span');
                slider.addEventListener('input', () => {
                    const newValue = parseInt(slider.value);
                    valueDisplay.textContent = newValue;
                    socket.emit('setDmxChannel', { channel: i, value: newValue });
                });

                const midiLearnButton = channelDiv.querySelector('.midi-learn');
                midiLearnButton.addEventListener('click', () => {
                    if (currentMidiLearnButton) {
                        currentMidiLearnButton.classList.remove('learning');
                        socket.emit('stopMidiLearn');
                    }
                    if (currentMidiLearnButton !== midiLearnButton) {
                        midiLearnButton.classList.add('learning');
                        socket.emit('startMidiLearn', i);
                        currentMidiLearnButton = midiLearnButton;
                    } else {
                        currentMidiLearnButton = null;
                    }
                });

                const oscInput = channelDiv.querySelector('.osc-value');
                oscInput.addEventListener('change', () => {
                    socket.emit('setDmxChannelOsc', { channel: i, oscValue: oscInput.value });
                });
            }

            // Display groups and their controls
            groups.forEach((group, groupIndex) => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'group-item';
                groupDiv.innerHTML = `
                    <h3>${group.name}</h3>
                    <div class="group-channels"></div>
                `;
                const groupChannelsDiv = groupDiv.querySelector('.group-channels');

                const channelTypes = ['intensity', 'pan', 'tilt', 'color', 'gobo'];
                channelTypes.forEach(channelType => {
                    const channelDiv = document.createElement('div');
                    channelDiv.className = 'group-channel';
                    channelDiv.innerHTML = `
                        <label for="group-${groupIndex}-${channelType}">${channelType.charAt(0).toUpperCase() + channelType.slice(1)}:</label>
                        <input type="range" id="group-${groupIndex}-${channelType}" min="0" max="255" value="0">
                        <span>0</span>
                    `;
                    groupChannelsDiv.appendChild(channelDiv);

                    const slider = channelDiv.querySelector('input');
                    const valueDisplay = channelDiv.querySelector('span');
                    slider.addEventListener('input', () => {
                        const newValue = parseInt(slider.value);
                        valueDisplay.textContent = newValue;
                        socket.emit('setGroupChannel', { groupIndex, channelType, value: newValue });
                    });
                });

                groupControlsContainer.appendChild(groupDiv);
            });

            // Update fixture options in group form
            const groupFixturesSelect = document.getElementById('groupFixtures');
            groupFixturesSelect.innerHTML = '';
            fixtures.forEach((fixture, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = fixture.name;
                groupFixturesSelect.appendChild(option);
            });
        });

        // Handle DMX updates
        socket.on('dmxUpdate', ({ channel, value }) => {
            log(`DMX update: Channel ${channel}, Value ${value}`);
            const slider = document.querySelector(`input[id^="dmx-${channel}"], input[id^="fixture-"][id$="-${channel % 512}"]`);
            if (slider) {
                const valueDisplay = slider.nextElementSibling;
                slider.value = value;
                valueDisplay.textContent = value;
            }
        });

        // Handle ArtNET diagnostics
        socket.on('artnetDiagnostics', (diagnostics) => {
            log(`Received ArtNET diagnostics: ${JSON.stringify(diagnostics)}`);
            document.getElementById('artnetIp').textContent = diagnostics.ip;
            document.getElementById('artnetUniverse').textContent = diagnostics.universe;
            document.getElementById('artnetStatus').textContent = diagnostics.status;
            document.getElementById('artnetChannelsTransmitted').textContent = diagnostics.channelsTransmitted;
            document.getElementById('artnetTotalChannels').textContent = diagnostics.totalChannels;
        });

        // Handle Scene List
        socket.on('sceneList', (scenes) => {
            log(`Received scene list: ${JSON.stringify(scenes)}`);
            if (scenesWindow && !scenesWindow.closed) {
                scenesWindow.updateSceneList(scenes);
            }
        });

        // Handle Scene Loaded
        socket.on('sceneLoaded', (scene) => {
            log(`Scene loaded: ${JSON.stringify(scene)}`);
            showStatusMessage(`Scene loaded: ${scene.name}`);
        });

        // Handle Scene Added or Updated
        socket.on('sceneAdded', (scene) => {
            log(`Scene added: ${JSON.stringify(scene)}`);
            showStatusMessage(`Scene saved: ${scene.name}`);
            socket.emit('getSceneList');
        });

        socket.on('sceneUpdated', (scene) => {
            log(`Scene updated: ${JSON.stringify(scene)}`);
            showStatusMessage(`Scene updated: ${scene.name}`);
            socket.emit('getSceneList');
        });

        // Handle Scene OSC Updated
        socket.on('sceneOscUpdated', (scene) => {
            log(`Scene OSC updated: ${JSON.stringify(scene)}`);
            showStatusMessage(`Scene OSC updated: ${scene.name}`);
            socket.emit('getSceneList');
        });

        // Handle Scene MIDI Learn
        socket.on('sceneMidiLearned', (data) => {
            log(`Scene MIDI learned: ${JSON.stringify(data)}`);
            showStatusMessage(`MIDI learned for scene: ${data.sceneName}`);
            socket.emit('getSceneList');
        });

        // Handle Scene MIDI Forget
        socket.on('sceneMidiForgotten', (data) => {
            log(`Scene MIDI forgotten: ${JSON.stringify(data)}`);
            showStatusMessage(`MIDI forgotten for scene: ${data.sceneName}`);
            socket.emit('getSceneList');
        });

        // Handle errors
        socket.on('error', (error) => {
            log(`Error: ${error.message}`);
            showStatusMessage(error.message, true);
        });

        // Ensure initial visibility of main control section and load initial state
        showSection('mainControl');
        log('Requesting initial state');
        socket.emit('getInitialState');
    </script>
</body>
</html>